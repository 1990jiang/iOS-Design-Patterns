# iOS-DesignPatterns

### MementoPattern

> 备忘录设计模式的完整实现

![demo.gif](http://images2015.cnblogs.com/blog/607542/201509/607542-20150911211147387-467686442.gif)

* 在不破坏封装的情况下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可以将该对象恢复到原先保存的状态
* 本人已经将创建状态与恢复状态的逻辑抽象成了协议，并配合备忘录中心一起使用


### SingletonPattern

> [严格单例模式的完整实现](http://www.cnblogs.com/YouXianMing/p/4709209.html)

![demo.png](http://images0.cnblogs.com/blog2015/607542/201508/062107342681020.png)

* 单例模式人人用过,严格的单例模式很少有人用过
* 严格的单例模式指的是无法通过常规的 alloc init 方法来生成对象,派生出来的子类也不能产生出对象,而只能通过单例的方法获取到对象


### FlyweightPattern

> 享元设计模式的完整实现

![demo.png](http://images2015.cnblogs.com/blog/607542/201510/607542-20151027172216122-262635664.png)

* 享元模式使用共享物件，用来尽可能减少内存使用量以及分享资讯给尽可能多的相似物件；它适合用于只是因重复而导致使用无法令人接受的大量内存的大量物件。通常物件中的部分状态是可以分享。常见做法是把它们放在外部数据结构，当需要使用时再将它们传递给享元。


### ChainOfResponsibilityPattern

> 责任链设计模式的完整实现

![demo.png](http://images2015.cnblogs.com/blog/607542/201510/607542-20151027145216575-700989924.png)

* 在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任。


### VisitorPattern

> 访问者设计模式的完整实现

![demo.png](http://images2015.cnblogs.com/blog/607542/201510/607542-20151027105704513-2073306262.png)

* 表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素类的前提下定义作用于这些元素的新操作。


### IteratorPattern

> 迭代器设计模式的完整实现

![demo.png](http://images2015.cnblogs.com/blog/607542/201510/607542-20151026143404825-134177288.png)

* 提供一种方法顺序访问一个聚合对象中的各种元素，而又不暴露该对象的内部表示。 


### CompositePattern

> 组合设计模式的完整实现

![demo.png](http://images2015.cnblogs.com/blog/607542/201510/607542-20151017215057132-320922577.png)

* 将对象组合成树形结构以表示“部分-整体”的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。掌握组合模式的重点是要理解清楚 “部分/整体” 还有 ”单个对象“ 与 "组合对象" 的含义。


### CommandPattern

> 命令设计模式的完整实现

![demo.png](http://images2015.cnblogs.com/blog/607542/201510/607542-20151017215057132-320922577.png)

* 命令对象封装了如何对目标执行指令的信息，因此客户端或调用者不必了解目标的任何细节，却仍可以对他执行任何已有的操作。通过把请求封装成对象，客户端可以把它参数化并置入队列或日志中，也能够支持可撤销操作。命令对象将一个或多个动作绑定到特定的接收器。命令模式消除了作为对象的动作和执行它的接收器之间的绑定。
